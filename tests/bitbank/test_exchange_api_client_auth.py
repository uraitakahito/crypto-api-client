"""bitbank ExchangeApiClient authentication and signature generation tests

This test was added to detect signature error issues that occurred when
'/' was removed from stub_path during refactoring.

Important validation points:
1. endpoint_path in signature message generated by _build_auth_headers starts with '/'
2. endpoint_path generated by each Private API method is correct
"""

import httpx
import pytest
from pydantic import SecretStr
from yarl import URL

from crypto_api_client.bitbank.bitbank_api_client_factory import (
    BitbankApiClientFactory,
)
from crypto_api_client.http._http_method import HttpMethod


class TestExchangeApiClientEndpointPathGeneration:
    """ExchangeApiClient endpoint_path generation tests

    Detects the issue where endpoint_path no longer starts with '/' due to
    removing '/' from stub_path during refactoring, causing signature errors.
    """

    @pytest.fixture
    def factory(self):
        """Factory instance"""
        return BitbankApiClientFactory()

    @pytest.fixture
    def api_client(self, factory):
        """API client for testing"""
        http_client = httpx.AsyncClient()
        client = factory.create(
            api_key=SecretStr("test_api_key"),
            api_secret=SecretStr("test_api_secret"),
            http_client=http_client,
            callbacks=None,
            request_config={"timeout": 30.0},
        )
        return client

    def test_stub_path_does_not_start_with_slash(self, factory):
        """Verify private_stub_path does not start with '/'

        Specification after refactoring: private_stub_path does not start with '/'
        """
        config = factory.get_default_config()
        stub_path = config["private_relative_stub_path"]

        # private_stub_path does not start with '/'
        assert not stub_path.path.startswith("/")
        # private_stub_path is 'v1'
        assert stub_path.path == "v1"

    def test_endpoint_path_generation_for_private_api(self, factory):
        """Verify endpoint_path generation for Private API is correct

        Important: endpoint_path must always start with '/' (for signature generation)
        """
        config = factory.get_default_config()

        # Test case: assets
        resource_identifier_path = config["relative_user_resource_identifier_path"]
        action_name = config["assets_action_name"]
        resource_path = resource_identifier_path.joinpath(action_name.path)

        # endpoint_path generation logic actually used in ExchangeApiClient
        endpoint_path = URL("/") / config["private_relative_stub_path"].path / resource_path.path

        # endpoint_path starts with '/'
        assert endpoint_path.path.startswith("/"), (
            f"endpoint_path must start with '/'. Got: {endpoint_path.path}"
        )

        # Expected value: /v1/user/assets
        assert endpoint_path.path == "/v1/user/assets"

    def test_all_private_api_endpoint_paths_start_with_slash(self, factory):
        """Verify all Private API endpoint_paths start with '/'"""
        config = factory.get_default_config()

        # All Private API endpoints
        private_api_actions = [
            ("assets", "relative_user_resource_identifier_path", "assets_action_name"),
            ("create_order", "relative_user_spot_resource_identifier_path", "order_action_name"),
        ]

        for api_name, resource_key, action_key in private_api_actions:
            resource_identifier_path = config[resource_key]
            action_name = config[action_key]
            resource_path = resource_identifier_path.joinpath(action_name.path)

            # endpoint_path generation logic actually used in ExchangeApiClient
            endpoint_path = URL("/") / config["private_relative_stub_path"].path / resource_path.path

            # endpoint_path must always start with '/'
            assert endpoint_path.path.startswith("/"), (
                f"{api_name}: endpoint_path must start with '/'. Got: {endpoint_path.path}"
            )

            # endpoint_path starts with '/v1/user/'
            assert endpoint_path.path.startswith("/v1/user"), (
                f"{api_name}: endpoint_path should start with '/v1/user'. Got: {endpoint_path.path}"
            )

    def test_build_auth_headers_signature_format(self, api_client):
        """Verify _build_auth_headers generates signature in correct format

        This is an integration test that actually calls the signature generation logic.
        """
        # Parameters for testing
        endpoint_path = URL("/v1/user/assets")
        request_time = "1640000000000"
        time_window = "5000"

        # Call _build_auth_headers
        headers = api_client._build_auth_headers(
            api_key=SecretStr("test_api_key"),
            api_secret=SecretStr("test_api_secret"),
            method=HttpMethod.GET,
            endpoint_path=endpoint_path,
            query_params=None,
            request_body=None,
            request_time=request_time,
            time_window_millisecond=time_window,
        )

        # Verify headers are correctly generated
        assert "ACCESS-KEY" in headers
        assert "ACCESS-REQUEST-TIME" in headers
        assert "ACCESS-TIME-WINDOW" in headers
        assert "ACCESS-SIGNATURE" in headers

        # Verify timestamp is correct
        assert headers["ACCESS-REQUEST-TIME"] == request_time
        assert headers["ACCESS-TIME-WINDOW"] == time_window

    def test_regression_endpoint_path_without_leading_slash_would_fail(self, factory):
        """Regression test: Detect issue when endpoint_path doesn't start with '/'

        This test is to detect the problem that occurred when '/' was removed
        from stub_path during refactoring in the future.

        If mistakenly implemented as follows, this test will fail:
            endpoint_path = private_stub_path.joinpath(resource_path.path)
            # â†’ 'v1/user/assets' (no leading '/')
        """
        config = factory.get_default_config()

        resource_identifier_path = config["relative_user_resource_identifier_path"]
        action_name = config["assets_action_name"]
        resource_path = resource_identifier_path.joinpath(action_name.path)

        # [Incorrect implementation] Use private_stub_path as-is (doesn't start with '/')
        wrong_endpoint_path = config["private_relative_stub_path"].joinpath(resource_path.path)

        # [Correct implementation] Explicitly add '/'
        correct_endpoint_path = URL("/") / config["private_relative_stub_path"].path / resource_path.path

        # Incorrect implementation doesn't start with '/'
        assert not wrong_endpoint_path.path.startswith("/"), (
            "This demonstrates the bug: endpoint_path doesn't start with '/'"
        )

        # Correct implementation starts with '/'
        assert correct_endpoint_path.path.startswith("/"), (
            "Correct implementation: endpoint_path must start with '/'"
        )

        # Both are different
        assert wrong_endpoint_path.path != correct_endpoint_path.path


class TestPrivateApiMethodsEndpointPath:
    """Verify Private API methods generate correct endpoint_path

    This confirms endpoint_path is correct during actual method calls.
    """

    @pytest.fixture
    async def api_client(self):
        """API client for testing"""
        factory = BitbankApiClientFactory()
        async with httpx.AsyncClient() as http_client:
            client = factory.create(
                api_key=SecretStr("test_api_key"),
                api_secret=SecretStr("test_api_secret"),
                http_client=http_client,
                callbacks=None,
                request_config={"timeout": 30.0},
            )
            yield client

    async def test_assets_generates_correct_endpoint_path(self, api_client, mocker):
        """Verify assets() uses correct endpoint_path"""
        from crypto_api_client.bitbank._signature_builder import build_message

        # Mock build_message to capture passed endpoint_path
        original_build_message = build_message
        captured_endpoint_paths = []

        def mock_build_message(**kwargs):
            captured_endpoint_paths.append(kwargs["endpoint_path"])
            return original_build_message(**kwargs)

        mocker.patch(
            "crypto_api_client.bitbank.exchange_api_client.build_message",
            side_effect=mock_build_message
        )

        # Mock HTTP request to avoid actual communication
        mock_response = mocker.Mock()
        mock_response.status_code = 200
        mock_response.text = '{"success":1,"data":{"assets":[]}}'
        mock_response.headers = {}
        mocker.patch.object(
            api_client._http_client,
            "request",
            return_value=mock_response
        )

        # Call assets()
        try:
            await api_client.assets()
        except Exception:
            pass  # Ignore errors (purpose is to capture endpoint_path)

        # Verify endpoint_path is correct
        assert len(captured_endpoint_paths) > 0
        endpoint_path = captured_endpoint_paths[0]

        # endpoint_path must always start with '/'
        assert endpoint_path.path.startswith("/"), (
            f"endpoint_path must start with '/'. Got: {endpoint_path.path}"
        )

        # endpoint_path is '/v1/user/assets'
        assert endpoint_path.path == "/v1/user/assets", (
            f"Expected '/v1/user/assets', got: {endpoint_path.path}"
        )


class TestSignatureGenerationRegression:
    """Signature generation regression tests

    Tests to detect problems that occurred in the past.
    """

    def test_signature_changes_when_endpoint_path_format_changes(self):
        """Verify signature changes when endpoint_path format changes

        This demonstrates that presence/absence of '/' affects signature.
        """
        from crypto_api_client.bitbank._signature_builder import build_message

        request_time = "1640000000000"
        time_window = "5000"

        # Starts with '/' (correct)
        msg_correct = build_message(
            method=HttpMethod.GET,
            endpoint_path=URL("/v1/user/assets"),
            query_params=None,
            request_body=None,
            request_time=request_time,
            time_window_millisecond=time_window,
        )

        # Doesn't start with '/' (incorrect)
        msg_wrong = build_message(
            method=HttpMethod.GET,
            endpoint_path=URL("v1/user/assets"),
            query_params=None,
            request_body=None,
            request_time=request_time,
            time_window_millisecond=time_window,
        )

        # Signature messages are different
        assert msg_correct != msg_wrong

        # Correct format: "16400000000005000/v1/user/assets"
        assert msg_correct == "16400000000005000/v1/user/assets"

        # Incorrect format: "16400000000005000v1/user/assets"
        assert msg_wrong == "16400000000005000v1/user/assets"
